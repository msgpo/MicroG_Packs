#!/sbin/sh
# Minimal MicroG installer
# based on work by osm0sis @ xda-developers (Thanks!)

outfd=/proc/self/fd/$2;
zipfile="$3";
zipdir="$(dirname $zipfile)";
ps | grep zygote | grep -v grep >/dev/null && bootmode=true || bootmode=false;
$bootmode || ps -A 2>/dev/null | grep zygote | grep -v grep >/dev/null && bootmode=true;

ui_print() { 
 $bootmode && echo "$1" || echo -e "ui_print $1\nui_print" >> $outfd; 
}

file_getprop() { 
 grep "^$2" "$1" | head -n1 | cut -d= -f2; 
} 

log() { 
 $bootmode && { mkdir -p "$moddir"; echo "$@" >> $logfile; } || echo $@; 
}

abort() { 
  ui_print " ";
  ui_print "FATAL ERROR: $1";
  ui_print "Stopping installation and Uninstalling...";
  uninstall_pack;
  ui_print " ";
  ui_print "Installation failed... Exiting...";
  ui_print "Please provide logs on the Telegram group";
  $bootmode || cat /tmp/recovery.log >> "$logfile"; 
  exit 1;
} 

ui_print " ";
ui_print "--     Minimal MicroG Installer     --";
ui_print "-- The Essentials only MicroG pack  --";
ui_print "--  From the MicroG Telegram group  --";
ui_print "--       No, not the Nazi one       --";
modname="MinMicroG";

# The stuff below is just related with mounting 
ui_print " "; 
ui_print "Mounting..."; 
mount -o ro /system; 
mount /data; 
mount /cache; 
mount /sdcard;
test -f "/system/system/build.prop" && sysroot="/system";
# Magisk boot mode support
test -e /data/adb/magisk && adb=adb;
if $bootmode; then
  outfd=/proc/self/fd/0;
  dev=/dev;
  devtmp=/dev/tmp;
  if [ ! -f /data/$adb/magisk_merge.img ]; then
    (/system/bin/make_ext4fs -b 4096 -l 64M /data/$adb/magisk_merge.img || /system/bin/mke2fs -b 4096 -t ext4 /data/$adb/magisk_merge.img 64M) >/dev/null;
  fi;
fi;
# Magisk clean flash support
if [ -e /data/$adb/magisk -a ! -e /data/$adb/magisk.img ]; then
  /system/bin/make_ext4fs -b 4096 -l 64M /data/$adb/magisk.img || /system/bin/mke2fs -b 4096 -t ext4 /data/$adb/magisk.img 64M;
fi;
# root decider
suimg=$(ls /data/$adb/magisk_merge.img || ls /data/$adb/magisk.img || ls /cache/magisk.img) 2>/dev/null;
mnt=$devtmp/$(basename $suimg .img);
if [ "$suimg" ]; then
  umount $mnt;
  test ! -e $mnt && mkdir -p "$mnt";
  mount -t ext4 -o rw,noatime $suimg $mnt;
  for i in 0 1 2 3 4 5 6 7; do
    test "$(mount | grep " $mnt ")" && break;
    loop=/dev/block/loop$i;
    if [ ! -f "$loop" -o ! -b "$loop" ]; then
      mknod $loop b 7 $i;
    fi;
    losetup $loop $suimg && mount -t ext4 -o loop,noatime $loop $mnt;
  done;
  root="$mnt/$modname";
else
  mount /system;
  mount -o rw,remount /system;
  mount -o rw,remount /system /system;
  root="/$sysroot";
fi;

test -f "/$sysroot/system/build.prop" || abort "Could not find a ROM in $sysroot"; 
test "$root" || abort "Could not find a root";

filedir="$dev/tmp/$modname";
moddir="/data/media/0/$modname";
tmplibdir="$filedir/tmplibdir";
backupdir="$moddir/Backup";
logfile="$moddir/$modname-$(date +%Y%m%d%H%M%S).log";

# Extracts the default configuration (in case of uninstall)
mkdir -p "$filedir";
unzip -oq "$zipfile" "defminconf.sh" -d "$filedir/";
[ -f "$filedir/defminconf.sh" ] || abort "Could not find a default config";
chown 0:0 "$filedir/defminconf.sh"; 
chmod 0777 "$filedir/defminconf.sh"; 
. "$filedir/defminconf.sh" || abort "Could not execute default config";

ui_print " ";
ui_print "$variant Package";
ui_print "Version: $ver";
ui_print "Release date: $date";

# zip name having uninstall will cause uninstall
case $(basename "$zipfile") in
  *uninstall*|*Uninstall*|*UNINSTALL*) 
    action=uninstallation;
  ;;
  *) 
    action=installation;
  ;;
esac;

# zip name having system will cause system install
case $(basename "$zipfile") in
  *system*|*System*|*SYSTEM*) 
    mount /system;
    mount -o rw,remount /system;
    mount -o rw,remount /system /system;
    root="/$sysroot";
    ui_print " "; 
    ui_print "WARNING: Forcing a system $action!"; 
  ;;
esac;

# Check if installation involves Magisk
case $root in 
  *magisk*) 
    magisk=yes;
  ;;
esac;

# arches are: arm, arm64, x86, x86_64, mips, mips64
abi=`getprop ro.product.cpu.abi`;
case $abi in
  arm*|x86*|mips*) 
  ;;
  *) 
    abi=`file_getprop /default.prop ro.product.cpu.abi`;
  ;;
esac;
case $abi in
  arm*|x86*|mips*) 
  ;;
  *) 
    abi=`file_getprop $sysroot/system/build.prop ro.product.cpu.abi`;
  ;;
esac;
case $abi in
  arm64*) 
    arch=arm64;
    libarches="arm64-v8a armeabi-v7a armeabi"; 
  ;;
  arm*) 
    arch=arm;
    libarches="armeabi-v7a armeabi";
  ;;
  x86_64*) 
    arch=x86_64;
    libarches="x86_64 x86 armeabi-v7a armeabi";
  ;;
  x86*) 
    arch=x86;
    libarches="x86 armeabi-v7a armeabi";
  ;;
  mips64*) 
    arch=mips64;
    libarches="mips64 mips";
  ;;
  mips*) 
    arch=mips;
    libarches="mips";
  ;;
  *) 
    abort "Could not recognise architecture: $abi";
  ;;
esac;
ui_print " ";
ui_print "Using architecture: $arch";

# sdk is kinda obvious...
sdk=$(file_getprop $sysroot/system/build.prop ro.build.version.sdk); 
test $sdk || abort "Could not find SDK";
ui_print "Using SDK level: $sdk";
if [ "$sdk" -lt $minsdk ]; then
  ui_print " ";
  ui_print "WARNING: Using an old Android";
  ui_print "Full compatibility not guaranteed";
fi;

log "MinMicroG Installer";
log " ";
log "Zip File is $zipfile";
log "Bootmode is $bootmode";

# Tests if installer has that object, installs in correct location depending upon android, and calls for lib installation if APK
install() { 
  object="$1"; 
  destobject="$2";
  test -f "$object" || { log "ERROR: Object not found ($object)"; return 0; }
  if [ "$sdk" -lt 21 ]; then
    [ "$(basename $(dirname $destobject)).apk" == "$(basename $destobject)" ] && destobject="$(dirname $(dirname $destobject))/$(basename $destobject)";
  fi;
  uninstall "$destobject"; 
  mkdir -p "$(dirname $destobject)"; 
  mv -f "$object" "$destobject"; 
  test -f "$destobject" || abort "Could not install $destobject";
  case "$destobject" in 
    *.apk) 
      install_lib "$destobject"; 
    ;;
  esac;
  log "INSTALLER: Object installed ($object to $destobject)";
} 

# Checks if APK has libs, and installs correct ones if present
install_lib() {
  libobject="$1";
  rm -rf "$tmplibdir";
  mkdir -p "$tmplibdir";
  unset srcdir; 
  unzip -lq "$libobject" | grep lib/ | grep -v grep >/dev/null || { log "INSTALLER: Object does not have libs ($libobject)"; return 0; }
  unzip -oq "$libobject" "lib/*" -d "$tmplibdir";
  if [ -d "$tmplibdir/lib" ]; then 
    log "INSTALLER: Object has libs ($libobject)";
    for archlib in $libarches; do
      if [ -d "$tmplibdir/lib/$archlib" ]; then
        srcdir="$tmplibdir/lib/$archlib";
        break;
      fi;
    done;
    if [ -d "$srcdir" ]; then
      case "$srcdir" in
        *arm64*) 
          log "INSTALLER: Installing arm64 libs ($libobject)";
          lib_dir=lib64;
          libarch=arm64; 
        ;;
        *arm*) 
          log "INSTALLER: Installing arm libs ($libobject)";
          lib_dir=lib;
          libarch=arm; 
        ;;
        *x86_64*) 
          log "INSTALLER: Installing x86_64 libs ($libobject)";
          lib_dir=lib64;
          libarch=x86_64; 
        ;;
        *x86*) 
          log "INSTALLER: Installing x86 libs ($libobject)";
          lib_dir=lib;
          libarch=x86; 
        ;; 
        *mips64*) 
          log "INSTALLER: Installing mips64 libs ($libobject)";
          lib_dir=lib64;
          libarch=mips64; 
        ;; 
        *mips*) 
          log "INSTALLER: Installing mips libs ($libobject)";
          lib_dir=lib;
          libarch=mips; 
        ;; 
      esac;
      if [ "$sdk" -lt 21 ]; then
        libdest="$(dirname $(dirname $libobject))/$lib_dir";
      else 
        libdest="$(dirname $libobject)/lib/$libarch";
      fi;
      mkdir -p "$libdest";
      for lib in $srcdir/lib*.so; do 
        mv -f "$lib" "$libdest/$(basename $lib)"; 
        test -f "$libdest/$(basename $lib)" || abort "Could not Install $lib for $libobject"; 
        log "INSTALLER: Installed library ($lib to $libdest)";
      done; 
    else 
      log "INSTALLER: Could not find libs for $arch ($libobject)"; 
      return 0;
    fi; 
  else 
    abort "Could not unzip APK $libobject";
  fi;
  rm -rf "$tmplibdir";
}

# Finds all files and directories within input, and sets owners and permissions
perm_r() {
  dir="$1";
  owner="$2";
  group="$3";
  dmode="$4";
  fmode="$5";
  test -d "$dir" || return 0;
  for pdir in $(find "$dir" -type d); do
    chown "$owner":"$group" "$pdir" || log "Could not set owner $owner:$group on directory $pdir"; 
    chmod "$dmode" "$pdir" || log "Could not set permissions $dmode on directory $pdir"; 
  done;
  for pfile in $(find "$dir" -type f); do
    chown "$owner":"$group" "$pfile" || log "Could not set owner $owner:$group on file $pfile"; 
    chmod "$fmode" "$pfile" || log "Could not set permissions $fmode on file $pfile"; 
  done;
}

# If present, object is backed up if instructed, and then removed
remove() { 
  removalobject="$1"; 
  test -f "$removalobject" || return 0; 
  if [ "$backup" == "yes" ]; then 
    mkdir -p "$backupdir/$(dirname $removalobject)"; 
    cp -rf "$removalobject" "$backupdir/$(dirname $removalobject)/"; 
    test -f "$backupdir/$removalobject" || abort "Could not backup $removalobject";
    log "BACKUPER: Object backed up ($removalobject)";
  fi;
  rm -rf "$removalobject"; 
  test -f "$removalobject" && log "REMOVER: Object not removed ($removalobject)";
  log "REMOVER: Object removed ($removalobject)";
  [ "$(basename $(dirname $removalobject)).apk" == "$(basename $removalobject)" ] && { rm -rf "$(dirname $removalobject)"; log "REMOVER: Removed directory ($(dirname $removalobject))"; }
} 

# Object is heartlessly removed
uninstall() { 
  uninstallobject="$1";
  if [ "$sdk" -lt 21 ]; then
    [ "$(basename $(dirname $uninstallobject)).apk" == "$(basename $uninstallobject)" ] && uninstallobject="$(dirname $(dirname $uninstallobject))/$(basename $uninstallobject)";
  fi;
  test -f "$uninstallobject" || return 0; 
  rm -rf "$uninstallobject"; 
  test -f "$uninstallobject" && log "UNINSTALLER: Object not uninstalled ($uninstallobject)"; 
  log "UNINSTALLER: Object uninstalled ($uninstallobject)";
  [ "$(basename $(dirname $uninstallobject)).apk" == "$(basename $uninstallobject)" ] && { rm -rf "$(dirname $uninstallobject)"; log "UNINSTALLER: Removed directory ($(dirname $uninstallobject))"; }
} 

# Whole of uninstall action, For calling from abort()
uninstall_pack() { 
 
  ui_print " ";
  ui_print "Uninstalling from $root...";

  log " ";
  log "Uninstalling all stuff...";  
  for thing in $stuff_uninstall; do
    uninstall "$root/$thing"; 
  done;

  if [ "$magisk" == "yes" ]; then
    rm -rf "$root" || log "ERROR: Could not delete Magisk root ($root)";
  fi;

}

# Installation logic 
if [ "$action" == "installation" ]; then

  # Uninstalls old stuff from previous iterations (I'm a responsible person)
  ui_print " ";
  ui_print "Uninstalling duplicates...";  
  for thing in $stuff_uninstall; do
    uninstall "$root/$thing"; 
  done;

  ui_print " ";
  ui_print "Installing to $root..."; 
  if [ "$magisk" == "yes" ]; then
    rm -rf "$root"; 
  fi;
  mkdir -p "$root";

  ui_print " ";
  ui_print "Extracting files...";
  rm -rf "$filedir";
  mkdir -p "$filedir";
  unzip -oq "$zipfile" -d "$filedir" || abort "Could not unzip $zipfile";

  # Checks if user refused debloating
  case $(basename "$zipfile") in
    *bloat*|*Bloat*|*BLOAT*) 
      log "Not debloating due to user choice";
    ;; 
    *) 
      # NEVER, EVER modify system when it's running
      if [ "$bootmode" == "true" ]; then
        log "Not debloating due to bootmode being $bootmode";
      else 
        mount /system;
        mount -o rw,remount /system;
        mount -o rw,remount /system /system;
        ui_print " ";
        ui_print "Debloating...";
        # Check if user asked for backup
        case $(basename "$zipfile") in
          *backup*|*Backup*|*BACKUP*) 
            backup=yes;
            ui_print "With backups...";
          ;;
        esac;
        # Check for user debloater
        if [ -f "$zipdir/mindebloater.sh" ]; then 
          ui_print " "; 
          ui_print "Using user debloater"; 
          cp "$zipdir/mindebloater.sh" "$filedir/";
          chown 0:0 "$filedir/mindebloater.sh"; 
          chmod 0777 "$filedir/mindebloater.sh"; 
          . "$filedir/mindebloater.sh" || log "Could not execute user debloater"; 
        else 
          test -f "$filedir/debloater.sh" || { log "Debloater not found"; break; }
          chown 0:0 "$filedir/debloater.sh";
          chmod 0777 "$filedir/debloater.sh";
          . "$filedir/debloater.sh" || log "Could not execute debloater";
        fi;
      fi;
    ;;
  esac;

  # User config executer
  conf=$(ls "$zipdir/minmicrogconf.sh" || ls "$moddir/minmicrogconf.sh") 2>/dev/null;
  if [ -f "$conf" ]; then 
    ui_print " "; 
    ui_print "Using user config"; 
    cp "$conf" "$filedir/";
    chown 0:0 "$filedir/minmicrogconf.sh"; 
    chmod 0777 "$filedir/minmicrogconf.sh"; 
    . "$filedir/minmicrogconf.sh" || log "Could not execute user config ($conf)"; 
  fi;

  ui_print " ";
  ui_print "Installing $modname...";

  log " ";
  log "Installing generic stuff...";
  for thing in $stuff; do 
    install "$filedir/$thing" "$root/$thing"; 
  done;

  log " ";
  log "Installing Arch dependant stuff for $arch";
  for thing in $stuff_arch; do 
    install "$filedir/$(dirname $thing)/$arch/$(basename $thing)" "$root/$thing"; 
  done;

  log " ";
  log "Installing SDK dependant stuff for SDK $sdk";
  for thing in $stuff_sdk; do 
    install "$filedir/$(dirname $thing)/$sdk/$(basename $thing)" "$root/$thing"; 
  done;

  log " ";
  log "Installing Arch and SDK dependant stuff for $arch and SDK $sdk";
  for thing in $stuff_arch_sdk; do 
    install "$filedir/$(dirname $thing)/$arch-$sdk/$(basename $thing)" "$root/$thing"; 
  done;
  
  ui_print " ";
  ui_print "Setting permissions...";

  # Magisk is safe to be fully permed, but system is risky. So selective dirs
  if [ "$magisk" == "yes" ]; then
    perm_r "$root" 0 0 0755 0644;
  else
    for perm_dir in $perm_dirs; do 
      perm_r "$root/$perm_dir" 0 0 0755 0644;
    done;
  fi;
  
  misc_perms;

  # Magisk stuff
  if [ "$magisk" == "yes" ]; then
    cp -f "$filedir/module.prop" "$root/" || abort "Could not copy module.prop to $root";
    touch "$root/auto_mount" || abort "Could not create auto_mount in $root";
    chcon -hR 'u:object_r:system_file:s0' "$root";
    if $bootmode && [ "$suimg" == "/data/$adb/magisk_merge.img" ]; then
      test -e /magisk && imgmnt=/magisk || imgmnt=/sbin/.core/img;
      mkdir -p "$imgmnt/$modname";
      touch "$imgmnt/$modname/update" || abort "Could not create update in $imgmnt/$modname";
      cp -f "$filedir/module.prop" "$imgmnt/$modname/" || abort "Could not copy module.prop to $imgmnt/$modname";
    fi;
  fi;

fi;

# Uninstallation logic 
if [ "$action" == "uninstallation" ]; then 

  uninstall_pack;

fi;

ui_print " ";
ui_print "Successful!";
ui_print "Join us on Telegram: @NoGooLag";

ui_print " ";
ui_print "Unmounting...";
test "$suimg" && umount $mnt;
test "$loop" && losetup -d $loop;
umount /system;
umount /data;
umount /cache;

rm -rf $filedir;
$bootmode || cat /tmp/recovery.log >> "$logfile"; 
ui_print " ";
ui_print "Done!";
exit 0;
